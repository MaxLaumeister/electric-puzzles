<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <title>Electric Puzzles</title>
    <link href="favicon.ico" rel="icon" type="image/x-icon" />
    <link rel="canonical" href="https://www.maxlaumeister.com/electric-puzzles/" />
    <style>
        body {
            text-align: center;
        }
        canvas {
            -moz-user-select: none;
            -webkit-user-select: none;
            -ms-user-select: none;
            user-select: none;
        }
        .canvaswrap {
            display: inline-block;
            font-size: 0;
            border: solid black 20px;
            margin: 10px 0;
        }
        small {
            color: gray;
        }
    </style>
  </head>
  <body>
  <h1>Level ?</h1>
  <div class="canvaswrap">
    <canvas height="500" width="500"></canvas>
  </div>
  <br>
  <form action="">
    Signal Color: 
    <input id="rad_red" type="radio" value="red" checked="checked" onclick="grid.newSignalColor = 'red';">Red
    <input id="rad_green" type="radio" value="green" onclick="grid.newSignalColor = 'green';">Green
    <input id="rad_blue" type="radio" value="blue" onclick="grid.newSignalColor = 'blue';">Blue
    <input id="rad_black" type="radio" value="black" onclick="grid.newSignalColor = 'black';">Black
  </form>
  <br>
  <button onclick="prevLevel()">Prev Level</button>
  <button onclick="nextLevel()">Next Level</button>
  <table border="1" style="margin: 20px auto; margin-top: 60px;">
    <tr>
        <th>Level</th>
        <th>Par</th>
    </tr>
    <tr>
        <td>Level 1</td>
        <td>3</td>
    </tr>
    <tr>
        <td>Level 2</td>
        <td>6</td>
    </tr>
    <tr>
        <td>Level 3</td>
        <td>8</td>
    </tr>
    <tr>
        <td>Level 4</td>
        <td>?</td>
    </tr>
    <tr>
        <td>Level 5</td>
        <td>6</td>
    </tr>
    <tr>
        <td>Level 6</td>
        <td>2</td>
    </tr>
    <tr>
        <td>Level 7</td>
        <td>5</td>
    </tr>
    <tr>
        <td>Level 8</td>
        <td>?</td>
    </tr>
  </table>
  <p><small>Game prototype by <a href="https://www.maxlaumeister.com/">Maximillian Laumeister</a> &bull; <a href="https://github.com/MaxLaumeister/electric-puzzles">Source Code</a></small></p>
  <p><small>Sound effects CC-BY by <a href="https://freesound.org/people/LittleRobotSoundFactory/packs/16881/">LittleRobotSoundFactory</a>.</small></p>
    <script src="howler.min.js"></script>
    <script>
    let Util = {
        getNextCoord: function (ix, iy, orientation) {
            if (orientation === 0) {
                ix++;
            } else if (orientation === 1) {
                iy--;
            } else if (orientation === 2) {
                ix--;
            } else if (orientation === 3) {
                iy++;
            } else {
                throw "improper orientation";
            }
            return {x: ix, y: iy};
        }
    }
    
    class Grid {
      constructor(canvas) {
        this.c = canvas;
        this.ctx = canvas.getContext("2d");
        this.signalsUsed = 0;
        canvas.addEventListener('click', (e) => {
          this.handleClick(e.pageX - e.currentTarget.offsetLeft, e.pageY - e.currentTarget.offsetTop);
        });
      }
      
      loadData(data) {
        this.data = data;
        // Update component internal positions
        for (let i = 0; i < this.data.length; i++) {
            let row = this.data[i];
          for (let j = 0; j < row.length; j++) {
            let tile = row[j];
            if (tile) tile.setPosition(j, i);
          }
        }
      }
      
      getComponent(x, y) {
        return this.data[y][x];
      }
      
      update() {
        for (let i = 0; i < this.data.length; i++) {
            let row = this.data[i];
          for (let j = 0; j < row.length; j++) {
            let tile = row[j];
            if (tile) tile.update();
          }
        }
        
        for (let i = 0; i < this.data.length; i++) {
            let row = this.data[i];
          for (let j = 0; j < row.length; j++) {
            let tile = row[j];
            if (tile) tile.lateUpdate();
          }
        }
        //console.log("LateUpdated grid: ", JSON.stringify(this));
        
        // Check if level complete
        this.complete = true;
        for (let i = 0; i < this.data.length; i++) {
            let row = this.data[i];
            for (let j = 0; j < row.length; j++) {
              let tile = row[j];
              if (tile && tile.colorList && tile.colorList.length !== 0) this.complete = false;
            }
        }
      }
      
      draw() {
        //console.log("Grid drawing");
        
        this.ctx.beginPath();
        this.ctx.rect(0, 0, canvas.width, canvas.height);
        this.ctx.fillStyle = "black";
        this.ctx.fill();
        
        // Draw each tile
        
        for (let i = 0; i < this.data.length; i++) {
            let row = this.data[i];
            for (let j = 0; j < row.length; j++) {
                let dx, dy;
                dx = dy = canvas.width / this.data.length;
                let x = dx * j;
                let y = dy * i;
                
                // Draw background
                
                //this.ctx.beginPath();
                //this.ctx.rect(x+2,y+2,dx-4,dy-4);
                //this.ctx.fillStyle = "#ccc";
                //this.ctx.fill();
                
                // Draw component
                
                let tile = row[j];
                if (tile) tile.draw(this.ctx, x, y, dx, dy);
            }
        }
        
        // Draw stats
        
        this.ctx.font = "18px Arial";
        this.ctx.fillStyle = "red";
        this.ctx.fillText("Signals Used: " + this.signalsUsed,10,this.c.height - 10);
        
        if (this.complete) {
            this.ctx.beginPath();
            this.ctx.globalAlpha = 0.6;
            this.ctx.fillStyle = "white";
            this.ctx.rect(0, 0, this.c.width, this.c.height);
            this.ctx.fill();
            this.ctx.globalAlpha = 1;
            
            this.ctx.font = "24px Arial";
            this.ctx.textAlign="center"; 
            this.ctx.fillStyle = "lime";
            this.ctx.fillText("Level Complete!",this.c.width / 2,this.c.height / 2);
            this.ctx.textAlign="left";
        }
      }
      
      handleClick(x, y) {
        // super.handleClick(x, y);
        console.log("canvas clicked: (" + x + ", " + y + ")");
        let dx, dy;
        dx = dy = canvas.width / this.data.length;
        let xCoord = Math.floor(x / dx);
        let yCoord = Math.floor(y / dy);
        let tile = this.getComponent(xCoord, yCoord);
        if (tile) tile.handleClick();
        this.draw();
      }
    }

    class Component {
      constructor(orientation) {
        this.signals = [];
        this.newSignals = [];
        this.x = null;
        this.y = null;
        this.orientation = orientation;
      }
      
      setPosition(x, y) {
        this.x = x;
        this.y = y;
      }
      
      processSignals() {
        throw "unimplemented";
      }
      
      receiveSignal(signal) {
        //console.log("Signal received");
        this.newSignals.push(signal);
      }
      
      update() {
        this.processSignals();
      }
      
      lateUpdate() {
        this.signals = this.signals.concat(this.newSignals);
        this.newSignals = [];
      }
      
      handleClick() {
        // do nothing
        console.log("Component clicked at grid coord (" + this.x + ", " + this.y + ")");
      }
      
      draw(ctx, x, y, dx, dy) {
        //console.log("Draw component");
      }
    }
    
    class HoldingTube extends Component {
        constructor(orientation) {
            super(orientation);
            this.releasing = false;
        }
        
        receiveSignal(signal) {
            super.receiveSignal(signal);
            if (this.signals.length < 2) gamesound.holder.play();
            else if (!this.releasing) gamesound.holdingTubeRelease.play();
        }
        
        processSignals() {
            if (this.signals.length >= 3) {
                this.releasing = true;
            }
            if (this.releasing) {
                let signal = this.signals.shift();
                if (!signal) {
                    this.releasing = false;
                    return;
                }
                let n = Util.getNextCoord(this.x, this.y, this.orientation);
                signal.orientation = this.orientation;
                let nextComponent = grid.getComponent(n.x, n.y);
                if (nextComponent) nextComponent.receiveSignal(signal);
            }
        }
        
        lateUpdate() {
            if (!this.releasing) {
                this.signals = this.signals.concat(this.newSignals);
                this.newSignals = [];
            }
        }
        
        draw(ctx, x, y, dx, dy) {
            // Draw component image background
            
            ctx.save();
            ctx.translate(x + dx/2, y + dy/2);
            ctx.rotate( (-this.orientation * 90) * Math.PI/180);
            ctx.drawImage(Catcher.image, -dx/2, -dy/2, dx, dy);
            ctx.restore();
            
            // Draw held signal underlay
            
            for (let i = 0; i < 3; i++) {
                ctx.beginPath();
                ctx.rect(x+20,y+35 - i * 15,dx-40,dy-40);
                ctx.fillStyle = "#bbb";
                ctx.fill();
            }
            
            // Draw held signals
            
            let offset = 0;
            for (let signal of this.signals) {
                ctx.beginPath();
                ctx.rect(x+20,y+35 - offset,dx-40,dy-40);
                ctx.fillStyle = signal.color;
                ctx.fill();
                offset += 15;
            }
          }
    }
    
    class Holder extends Component {
        constructor(orientation) {
            super(orientation);
            this.held = null;
        }
        
        processSignals() {
            let signal = this.signals.shift();
            if (!signal) return;
            // New signal
            //console.log("Found signal");
            let toRelease = this.held;
            this.held = signal;
            if (!toRelease) return;
            // Signal there already, release old signal
            let n = Util.getNextCoord(this.x, this.y, signal.orientation);
            toRelease.orientation = signal.orientation;
            let nextComponent = grid.getComponent(n.x, n.y);
            if (nextComponent) nextComponent.receiveSignal(toRelease);
        }
        
        receiveSignal(signal) {
            super.receiveSignal(signal);
            gamesound.holder.play();
        }
        
        draw(ctx, x, y, dx, dy) {
            ctx.save();
            ctx.translate(x + dx/2, y + dy/2);
            ctx.rotate( (-this.orientation * 90) * Math.PI/180);
            ctx.drawImage(Holder.image, -dx/2, -dy/2, dx, dy);
            ctx.restore();
            
            // Draw held signal
            
            if(this.held || this.signals.length) {
                ctx.beginPath();
                ctx.rect(x+20,y+20,dx-40,dy-40);
                ctx.fillStyle = this.signals[0] ? this.signals[0].color : this.held.color;
                ctx.fill();
            }
          }
    }
    Holder.image = new Image();
    Holder.image.src = "holder.png";
    
    class Wire2Way extends Component {
        constructor(orientation) {
            super(orientation);
        }
        
        processSignals() {
            let signal = this.signals.shift();
            if (!signal) return;
            let n = Util.getNextCoord(this.x, this.y, signal.orientation);
            let nextComponent = grid.getComponent(n.x, n.y);
            if (nextComponent) nextComponent.receiveSignal(signal);
        }
        
        draw(ctx, x, y, dx, dy) {
            ctx.save();
            ctx.translate(x + dx/2, y + dy/2);
            ctx.rotate( (-this.orientation * 90) * Math.PI/180);
            ctx.drawImage(Wire2Way.image, -dx/2, -dy/2, dx, dy);
            ctx.restore();
            
            // Draw signal
            
            if (this.signals.length !== 0) {
                ctx.beginPath();
                ctx.rect(x+20,y+20,dx-40,dy-40);
                ctx.fillStyle = this.signals[0].color;
                ctx.fill();
            }
          }
    }
    Wire2Way.image = new Image();
    Wire2Way.image.src = "straight.png";
    
    class Wire2WayWithSignal extends Wire2Way {
        constructor(orientation, color) {
            super(orientation);
            this.signals.push(new Signal(orientation, color));
        }
    }
    
    class Wire4Way extends Wire2Way {
        constructor(orientation) {
            super(orientation);
        }
        draw(ctx, x, y, dx, dy) {
            ctx.save();
            ctx.translate(x + dx/2, y + dy/2);
            ctx.rotate( (-this.orientation * 90) * Math.PI/180);
            ctx.drawImage(Wire4Way.image, -dx/2, -dy/2, dx, dy);
            ctx.restore();
            
            // Draw signal
            
            if (this.signals.length !== 0) {
                ctx.beginPath();
                ctx.rect(x+20,y+20,dx-40,dy-40);
                ctx.fillStyle = this.signals[0].color;
                ctx.fill();
            }
          }
    }
    Wire4Way.image = new Image();
    Wire4Way.image.src = "4way.png";
    
    class WireBend extends Component {
        constructor(orientation) {
            super(orientation);
            this.lookupTable = [
                [0, 1, 1, 0],
                [1, 1, 2, 2],
                [3, 2, 2, 3],
                [0, 0, 3, 3]
            ];
        }
        
        processSignals() {
            let signal = this.signals.shift();
            if (!signal) return;
            let targetOrientation = this.lookupTable[this.orientation][signal.orientation];
            signal.orientation = targetOrientation;
            let n = Util.getNextCoord(this.x, this.y, targetOrientation);
            let nextComponent = grid.getComponent(n.x, n.y);
            if (nextComponent) nextComponent.receiveSignal(signal);
        }
        
        draw(ctx, x, y, dx, dy) {
            ctx.save();
            ctx.translate(x + dx/2, y + dy/2);
            ctx.rotate( (-this.orientation * 90) * Math.PI/180);
            ctx.drawImage(WireBend.image, -dx/2, -dy/2, dx, dy);
            ctx.restore();
            
            // Draw signal
            
            if (this.signals.length !== 0) {
                ctx.beginPath();
                ctx.rect(x+20,y+20,dx-40,dy-40);
                ctx.fillStyle = this.signals[0].color;
                ctx.fill();
            }
          }
    }
    WireBend.image = new Image();
    WireBend.image.src = "elbow.png";
    
    class Duplicator extends Component {
        constructor(orientation) {
            super(orientation);
        }
        
        receiveSignal(signal) {
            super.receiveSignal(signal);
            gamesound.duplicator.play();
        }
        
        processSignals() {
            let signal = this.signals.shift();
            if (!signal) return;
            
            let signalCopy = JSON.parse(JSON.stringify(signal));
            
            let n1 = Util.getNextCoord(this.x, this.y, 0);
            let nextComponent1 = grid.getComponent(n1.x, n1.y);
            signal.orientation = 0;
            if (nextComponent1) nextComponent1.receiveSignal(signal);
            
            let n2 = Util.getNextCoord(this.x, this.y, 2);
            let nextComponent2 = grid.getComponent(n2.x, n2.y);
            signalCopy.orientation = 2;
            if (nextComponent2) nextComponent2.receiveSignal(signalCopy);
        }
        
        draw(ctx, x, y, dx, dy) {
            ctx.save();
            ctx.translate(x + dx/2, y + dy/2);
            ctx.rotate( (-this.orientation * 90) * Math.PI/180);
            ctx.drawImage(Duplicator.image, -dx/2, -dy/2, dx, dy);
            ctx.restore();
            
            // Draw signal
            
            if (this.signals.length !== 0) {
                ctx.beginPath();
                ctx.rect(x+20,y+20,dx-40,dy-40);
                ctx.fillStyle = this.signals[0].color;
                ctx.fill();
            }
          }
    }
    Duplicator.image = new Image();
    Duplicator.image.src = "duplicator.png";
    
    class WireBendVariant1 extends WireBend {
        //constructor(orientation) {
        //    super(orientation);
        //}
        
        draw(ctx, x, y, dx, dy) {
            ctx.save();
            ctx.translate(x + dx/2, y + dy/2);
            ctx.rotate( (-this.orientation * 90) * Math.PI/180);
            ctx.drawImage(WireBendVariant1.image, -dx/2, -dy/2, dx, dy);
            ctx.restore();
            
            // Draw signal
            
            if (this.signals.length !== 0) {
                ctx.beginPath();
                ctx.rect(x+20,y+20,dx-40,dy-40);
                ctx.fillStyle = this.signals[0].color;
                ctx.fill();
            }
          }
    }
    WireBendVariant1.image = new Image();
    WireBendVariant1.image.src = "elbow-variant.png";
    
    class WireBendVariant2 extends WireBend {
        //constructor(orientation) {
        //    super(orientation);
        //}
        
        draw(ctx, x, y, dx, dy) {
            ctx.save();
            ctx.translate(x + dx/2, y + dy/2);
            ctx.scale(-1, 1);
            ctx.rotate( ((this.orientation + 3) * 90) * Math.PI/180);
            ctx.drawImage(WireBendVariant1.image, -dx/2, -dy/2, dx, dy);
            ctx.restore();
            
            // Draw signal
            
            if (this.signals.length !== 0) {
                ctx.beginPath();
                ctx.rect(x+20,y+20,dx-40,dy-40);
                ctx.fillStyle = this.signals[0].color;
                ctx.fill();
            }
          }
    }
    WireBendVariant2.image = new Image();
    WireBendVariant2.image.src = "elbow-variant.png";
    
    class WireBendVariant3 extends WireBend {
        //constructor(orientation) {
        //    super(orientation);
        //}
        
        draw(ctx, x, y, dx, dy) {
            ctx.save();
            ctx.translate(x + dx/2, y + dy/2);
            ctx.rotate( (-this.orientation * 90) * Math.PI/180);
            ctx.drawImage(WireBendVariant3.image, -dx/2, -dy/2, dx, dy);
            ctx.restore();
            
            // Draw signal
            
            if (this.signals.length !== 0) {
                ctx.beginPath();
                ctx.rect(x+20,y+20,dx-40,dy-40);
                ctx.fillStyle = this.signals[0].color;
                ctx.fill();
            }
          }
    }
    WireBendVariant3.image = new Image();
    WireBendVariant3.image.src = "elbow-variant3.png";
    
    class Diverter extends Component {
        constructor(orientation) {
            super(0);
            this.lookupTable = [
                [0, 0, 0, 0],
                [2, 2, 2, 2],
                [1, 1, 1, 1],
                [3, 3, 3, 3]
            ];
            this.state = orientation ? true : false;
        }
        
        processSignals() {
            let signal = this.signals.shift();
            if (!signal) return;
            
            // We have a signal
            
            gamesound.diverter.play();
            
            let targetOrientation;
            if (!this.state) targetOrientation = this.lookupTable[this.orientation][signal.orientation];
            else targetOrientation = this.lookupTable[this.orientation + 1][signal.orientation];
            signal.orientation = targetOrientation;
            let n = Util.getNextCoord(this.x, this.y, targetOrientation);
            let nextComponent = grid.getComponent(n.x, n.y);
            if (nextComponent) nextComponent.receiveSignal(signal);
            this.state = !this.state;
        }
        
        draw(ctx, x, y, dx, dy) {
            ctx.save();
            ctx.translate(x + dx/2, y + dy/2);
            if (this.state === true) ctx.scale(-1, 1);
            ctx.rotate( (-this.orientation * 90) * Math.PI/180);
            ctx.drawImage(Diverter.image, -dx/2, -dy/2, dx, dy);
            ctx.restore();
            
            // Draw signal
            
            if (this.signals.length !== 0) {
                ctx.beginPath();
                ctx.rect(x+20,y+20,dx-40,dy-40);
                ctx.fillStyle = this.signals[0].color;
                ctx.fill();
            }
          }
    }
    Diverter.image = new Image();
    Diverter.image.src = "diverter.png";
    
    class Diverter3Way extends Component {
        constructor(orientation) {
            super(orientation);
            this.lookupTable = [
                [3, 0, 1],
                [0, 1, 2],
                [1, 2, 3],
                [2, 3, 0]
            ];
            this.state = 0;
        }
        
        processSignals() {
            let signal = this.signals.shift();
            if (!signal) return;
            
            // We have a signal
            
            gamesound.diverter.play();
            
            let targetOrientation = this.lookupTable[this.orientation][this.state];
            signal.orientation = targetOrientation;
            let n = Util.getNextCoord(this.x, this.y, targetOrientation);
            let nextComponent = grid.getComponent(n.x, n.y);
            if (nextComponent) nextComponent.receiveSignal(signal);
            this.state++;
            if (this.state > 2) this.state = 0;
        }
        
        draw(ctx, x, y, dx, dy) {
            ctx.save();
            ctx.translate(x + dx/2, y + dy/2);
            if (this.state === 2) ctx.scale(-1, 1);
            //ctx.rotate( (-this.orientation * 90) * Math.PI/180);
            if (this.state === 1) ctx.drawImage(Diverter3Way.image2, -dx/2, -dy/2, dx, dy);
            else ctx.drawImage(Diverter3Way.image1, -dx/2, -dy/2, dx, dy);
            ctx.restore();
            
            // Draw signal
            
            if (this.signals.length !== 0) {
                ctx.beginPath();
                ctx.rect(x+20,y+20,dx-40,dy-40);
                ctx.fillStyle = this.signals[0].color;
                ctx.fill();
            }
          }
    }
    Diverter3Way.image1 = new Image();
    Diverter3Way.image1.src = "diverter-3way-1.png";
    Diverter3Way.image2 = new Image();
    Diverter3Way.image2.src = "diverter-3way-2.png";

    class Thrower extends Component {
      constructor(orientation) {
        super(orientation);
      }
      
      receiveSignal() {
        throw "Thrower can't receive signal";
      }
      
      handleClick() {
        super.handleClick();
        this.signals.push(new Signal(this.orientation, grid.newSignalColor));
        grid.signalsUsed++;
        console.log(this);
      }
      
      processSignals() {
        let signal = this.signals.shift();
        if (!signal) return;
        let n = Util.getNextCoord(this.x, this.y, signal.orientation);
        let nextComponent = grid.getComponent(n.x, n.y);
        if (nextComponent) nextComponent.receiveSignal(signal);
      }
      
      draw(ctx, x, y, dx, dy) {
        ctx.drawImage(Thrower.image, x, y, dx, dy);
        
        // Draw signal
        
        if (this.signals.length !== 0) {
            ctx.beginPath();
            ctx.rect(x+20,y+20,dx-40,dy-40);
            ctx.fillStyle = this.signals[0].color;
            ctx.fill();
        }
      }
    }
    Thrower.image = new Image();
    Thrower.image.src = "thrower.png";
    
    class Catcher extends Component {
      constructor(orientation, colorList) {
        super(orientation);
        this.colorList = colorList;
      }
      
      receiveSignal(signal) {
        if (this.colorList.length === 0) return;
        if (signal.color === this.colorList[0]) {
            this.colorList.shift(); // Color satisfied
            
            if (this.colorList.length !== 0) {
                // One color satisfied
                gamesound.signalReceived.play();
            } else {
                // All colors satisfied
                gamesound.allSignalsReceived.play();
            }
            
        } else {
            // Signal rejected
            gamesound.signalRejected.play();
        }
      }
      
      processSignals() {
        // do nothing
      }
      
      draw(ctx, x, y, dx, dy) {
        if (this.colorList.length === 0) ctx.drawImage(Catcher.imageSat, x, y, dx, dy);
        else ctx.drawImage(Catcher.image, x, y, dx, dy);
        
        // Draw the receptors
        
        let rcvX = -15;
        
        for (let i = 0; i < this.colorList.length; i++) {
            let color = this.colorList[i];
            
            if (i === 0) {
                ctx.beginPath();
                ctx.rect(x + 18 + rcvX,y+3,14,14);
                ctx.fillStyle = "black";
                ctx.fill();
                
                ctx.beginPath();
                ctx.rect(x + 19 + rcvX,y+4,12,12);
                ctx.fillStyle = "white";
                ctx.fill();
            }
            
            ctx.beginPath();
            ctx.rect(x + 20 + rcvX,y+5,10,10);
            ctx.fillStyle = color;
            ctx.fill();
            
            rcvX += 15;
        }
        
        // Draw signal
        
        //if (this.signals.length !== 0) {
        //    ctx.beginPath();
        //    ctx.rect(x+20,y+20,dx-40,dy-40);
        //    ctx.fillStyle = this.signals[0].color;
        //    ctx.fill();
        //}
      }
    }
    Catcher.image = new Image();
    Catcher.image.src = "catcher.png";
    Catcher.imageSat = new Image();
    Catcher.imageSat.src = "catcher-satisfied.png";

    class Signal {
      constructor(orientation, color) {
        this.orientation = orientation;
        this.color = color;
      }
    }
    
    let canvas = document.getElementsByTagName("canvas")[0];
    
    var currentLevel = 1;
    var levelGrids = [
        null,
        // Level 1
        [
          [null, null, null, null, null, null, null, null, null, null],
          [null, null, null, new Thrower(3), null, null, null, null, null, null],
          [null, null, null, new Wire2Way(3), null, null, null, null, null, null],
          [null, null, null, new WireBend(0), new Wire2Way(0), new WireBend(2), null, null, null, null],
          [null, null, null, null, new WireBend(3), new WireBend(1), null, null, null, null],
          [null, null, null, null, new Wire2Way(3), null, null, null, null, null],
          [null, null, null, null, new Wire2Way(3), null, null, null, null, null],
          [null, null, null, null, new Catcher(0, ["red", "blue", "blue"]), null, null, null, null, null],
          [null, null, null, null, null, null, null, null, null, null],
          [null, null, null, null, null, null, null, null, null, null]
        ],
        // Level 2
        [
          [null, null, null, null, null, new Thrower(3), null, null, null, null],
          [null, null, null, null, null, new Wire2Way(3), null, null, null, null],
          [null, null, null, new WireBend(3), new Wire2Way(2), new WireBendVariant2(2), null, null, null, null],
          [null, null, null, new Wire2Way(3), new WireBend(3), new Diverter(0), new WireBend(2), null, null, null],
          [null, null, null, new Wire2Way(3), new Wire2Way(3), null, new Wire2Way(3), null, null, null],
          [null, null, null, new Wire2Way(3), new Wire2Way(3), new WireBend(3), new Diverter(0), new WireBend(2), null, null],
          [null, null, null, new Wire2Way(3), new WireBendVariant1(3), new WireBend(1), null, new Wire2Way(3), null, null],
          [null, null, null, new WireBend(0), new Diverter(0), new WireBend(2), null, new Catcher(0, ["red", "green", "blue"]), null, null],
          [null, null, null, null, null, new Catcher(0, ["blue", "red", "green"]), null, null, null, null],
          [null, null, null, null, null, null, null, null, null, null]
        ],
        // Level 3
        [
          [null, null, new Thrower(3), null, new Thrower(3), null, null, null, null, null],
          [null, null, new Wire2Way(3), null, new WireBendVariant1(3), new Wire2Way(0), new Wire2Way(0), new WireBend(2), null, null],
          [null, null, new WireBendVariant1(3), new Wire2Way(0), new Diverter(0), new WireBend(2), null, new Wire2Way(3), null, null],
          [null, null, new Wire2Way(3), null, null, new Wire2Way(3), null, new Wire2Way(3), null, null],
          [null, null, new Holder(0), null, new WireBend(3), new WireBend(1), null, new Wire2Way(3), null, null],
          [null, null, new WireBendVariant1(3), new Wire2Way(0), new Diverter(0), new WireBend(2), null, new Wire2Way(3), null, null],
          [null, null, new Wire2Way(3), null, null, new Catcher(0, ["blue", "red", "green"]), null, new Wire2Way(3), null, null],
          [null, new WireBend(3), new Diverter(0), new WireBend(2), null, null, null, new Wire2Way(3), null, null],
          [null, new Catcher(0, ["red", "blue", "green", "blue"]), null, new WireBend(0), new Wire2Way(0), new Wire2Way(0), new Wire2Way(0), new WireBend(1), null, null],
          [null, null, null, null, null, null, null, null, null, null]
        ],
        // Level 4
        [
          [null, null, null, null, null, null, null, null, null, null],
          [null, null, null, null, new Thrower(3), null, null, null, null, null],
          [null, null, null, null, new Wire2Way(3), null, null, null, null, null],
          [new WireBend(3), new Wire2Way(0), new Wire2Way(0), new Wire2Way(0), new Diverter(0), new Wire2Way(0), new Wire2Way(0), new Wire2Way(0), new WireBend(2), null],
          [new Wire2Way(3), null, null, null, null, null, null, new WireBend(3), new Diverter(0), new WireBend(2)],
          [new WireBend(0), new WireBendVariant2(3), new Wire2Way(0), new Wire2Way(0), new Holder(0), new Wire2Way(0), new Wire2Way(0), new WireBendVariant3(2), new Wire2Way(0), new WireBend(1)],
          [null, new Wire2Way(3), null, null, null, null, null, new Wire2Way(3), null, null],
          [null, new WireBend(0), new WireBendVariant2(3), new Wire2Way(2), new Holder(0), new Wire2Way(2), new WireBendVariant1(2), new WireBend(1), null, null],
          [null, null, new Catcher(0, ["blue", "red", "green"]), null, null, null, new Catcher(0, ["green", "red"]), null, null, null],
          [null, null, null, null, null, null, null, null, null, null]
        ],
        // Level 5
        [
          [null, null, null, null, null, null, null, null, null, null],
          [null, null, null, null, null, null, null, null, null, null],
          [null, null, null, new Thrower(3), null, null, new Thrower(3), null, null, null],
          [null, null, null, new Wire2Way(3), null, null, new Wire2Way(3), null, null, null],
          [null, null, null, new WireBendVariant1(3), new Holder(0), new Wire2Way(0), new Duplicator(0), new WireBend(2), null, null],
          [null, null, null, new Wire2Way(3), null, null, new WireBend(3), new WireBend(1), null, null],
          [null, null, null, new Catcher(0, ["red", "green", "red", "green", "blue"]), null, null, new Catcher(0, ["red", "red", "green", "blue"]), null, null, null],
          [null, null, null, null, null, null, null, null, null, null, null],
          [null, null, null, null, null, null, null, null, null, null, null],
          [null, null, null, null, null, null, null, null, null, null, null]
        ],
        // Level 6
        [
          [null, null, new Thrower(3), null, null, null, null, new WireBend(3), new Wire2Way(2), new WireBend(2)],
          [null, null, new WireBendVariant1(3), new Wire2Way(0), new Wire2Way(0), new Wire2Way(0), new WireBendVariant1(2), new Duplicator(0), new WireBend(2), new Wire2Way(3)],
          [null, new WireBend(3), new Diverter(0), new Wire2Way(0), new WireBend(2), null, new Wire2Way(3), null, new Wire2WayWithSignal(3, "red"), new Wire2Way(3)],
          [new WireBend(3), new Duplicator(0), new WireBend(2), new WireBend(3), new Diverter(0), new Wire2Way(0), new WireBend(1), null, new Wire2Way(3), new Wire2Way(3)],
          [new Catcher(0, ["red", "green", "blue", "red"]), null, new Wire2Way(3), new Catcher(0, ["red", "green", "blue", "red"]), new Wire2Way(3), null, null, null, new Wire2Way(3), new Wire2Way(3)],
          [null, null, new WireBend(0), new Wire2Way(0), new WireBend(1), null, null, null, new Wire2Way(3), new Wire2Way(3)],
          [null, null, null, null, null, null, null, null, new Wire2Way(3), new Wire2Way(3)],
          [null, null, null, null, null, null, null, null, new Wire2Way(3), new Wire2Way(3)],
          [null, null, null, null, null, null, null, null, new Wire2Way(3), new Wire2Way(3)],
          [null, null, null, null, null, null, null, null, new WireBend(0), new WireBend(1)]
        ],
        // Level 7
        [
          [null, null, null, null, null, null, null, null, null, null, null],
          [null, null, null, null, null, new Thrower(3), null, null, null, null, null],
          [null, null, null, null, new WireBend(3), new WireBendVariant2(2), null, null, null, null, null],
          [null, null, null, null, new Wire2Way(3), new WireBendVariant1(3), new WireBend(2), null, null, null, null],
          [null, null, null, null, new Wire2Way(3), new HoldingTube(3), new WireBend(0), new WireBend(2), null, null, null],
          [null, null, null, null, new Wire2Way(3), new Wire2Way(3), new WireBend(3), new WireBend(1), null, null, null],
          [null, null, null, null, new WireBend(0), new Diverter3Way(3), new WireBendVariant1(1), null, null, null, null],
          [null, null, null, null, null, new Wire2Way(3), new Wire2Way(3), null, null, null, null],
          [null, null, null, null, new WireBend(3), new Diverter(1), new WireBend(1), null, null, null, null],
          [null, null, null, null, new Catcher(0, ["red", "green", "blue"]), null, null, null, null, null, null]
        ],
        // Level 8
        [
          [new WireBend(3), new Wire2Way(0), new Wire2Way(0), new Wire2Way(0), new WireBend(2), null, null, null, null, null],
          [new Wire2Way(3), new WireBend(3), new Wire2Way(0), new Wire2Way(0), new Wire4Way(0), new Wire2Way(0), new Wire2Way(0), new Wire2Way(0), new WireBend(2), null],
          [new Wire2Way(3), new Wire2Way(3), null, null, new WireBend(0), new Wire2Way(0), new Wire2Way(0), new WireBend(2), new Wire2Way(3), null],
          [new Wire2Way(3), new Wire2Way(3), null, new Thrower(3), null, new Thrower(3), null, new Wire2Way(3), new Wire2Way(3), null],
          [new Wire2Way(3), new Wire2Way(3), null, new Wire2Way(3), null, new Wire2Way(3), null, new Wire2Way(3), new Wire2Way(3), null],
          [new Wire2Way(3), new WireBendVariant1(3), new Wire2Way(0), new WireBend(1), null, new WireBend(0), new Wire2Way(0), new WireBendVariant2(2), new Wire2Way(3), null],
          [new Wire2Way(3), new HoldingTube(3), null, null, null, null, null, new HoldingTube(3), new Wire2Way(3), null],
          [new Wire2Way(3), new Wire2Way(3), null, null, null, null, null, new Wire2Way(3), new Wire2Way(3), null],
          [new WireBendVariant2(0), new Diverter(1), new WireBend(2), null, null, null, new WireBend(3), new Diverter(0), new WireBendVariant1(1), null],
          [new WireBend(0), new Wire2Way(0), new Diverter(1), new Catcher(0, ["red", "green", "blue"]), null, new Catcher(0, ["blue", "green", "red"]), new Diverter(0), new Wire2Way(0), new WireBend(1), null]
        ]
    ];
    
    let grid = new Grid(canvas);
    
    let querystring = window.location.search.substring(1);
    if (querystring) changeToLevel(querystring);
    else changeToLevel(1);
    
    grid.newSignalColor = "red";
    
    window.addEventListener("load", function(event) {
        grid.draw();
        window.setInterval(function() {
            grid.update();
            grid.draw();
        }, 500);
    });
    
    function nextLevel() {
        if (currentLevel > levelGrids.length - 2) {
            return;
        }
        currentLevel++;
        changeToLevel(currentLevel);
    }
    
    function prevLevel() {
        if (currentLevel <= 1) {
            return;
        }
        currentLevel--;
        changeToLevel(currentLevel);
    }
    
    function changeToLevel(num) {
        currentLevel = num;
        grid.loadData(levelGrids[num]);
        document.getElementsByTagName("h1")[0].textContent = "Level " + num;
        grid.signalsUsed = 0;
        grid.complete = false;
        grid.draw();
    }
    
    let gamesound = {
        diverter: new Howl({src:['274203__littlerobotsoundfactory__ui-synth-02-lowpass.wav']}),
        holder: new Howl({src:['274205__littlerobotsoundfactory__ui-synth-00-lowpass.wav']}),
        signalReceived: new Howl({src:['274204__littlerobotsoundfactory__ui-synth-01.wav']}),
        signalRejected: new Howl({src:['274196__littlerobotsoundfactory__ui-electric-05.wav']}),
        allSignalsReceived: new Howl({src:['274183__littlerobotsoundfactory__jingle-win-synth-04-lowpass.wav']}),
        duplicator: new Howl({src:['274207__littlerobotsoundfactory__ui-synth-04-lowpass.wav']}),
        holdingTubeRelease: new Howl({src:['19486__halleck__jacobsladdersingle1-edit.wav']})
    };
    
    // Preload sounds
    for (let sound in gamesound) {
        sound.preload = "auto";
    }
    </script>
  </body>
</html>
